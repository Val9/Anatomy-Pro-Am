<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<title>jGen Map Editor</title>

		
		
		
		<STYLE TYPE="text/css" MEDIA=screen>
		     <!--


		html, body {
			width: 100%;
			height: 100%;
			margin: 0px 0px 0px 0px;
			padding: 0px 0px 0px 0px;
			overflow: hidden;
			cursor: default;
			-webkit-user-select: none;
		}

		.toolbarButton {
			font-size: 12px;
			color:#444;
			background-color:#eee;
			font-family: tahoma;
			text-align: center;
			background-image:-webkit-gradient(linear, 0 0, 0 100%,
				color-stop(0, #fff),
				color-stop(0.05, #eee),
				color-stop(1, #bbb));
			text-shadow:0 1px 0 #f6f6f6;
			-webkit-border-radius: 4px;
			-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.3);
			width: 90px;
			height: 25px;
			line-height: 25px;
			margin-top: 10px;
		}

		.toolbarButton div {
			position: static;
			margin-top: -25px;
		}

		.toolbarButtonLeft {
			float: left;
			margin-left: 10px;
		}

		.toolbarButtonRight {
			float: right;
			margin-right: 10px;
		}

		.openFileDialog *,
		.saveFileDialog * {
			float: left;
			width: 90px;
			height: 25px;
			position: relative;
			line-height: 25px;
		}

		.hide-grid .showGrid {
			display: block;
		}

		.showGrid,
		.hide-grid .hideGrid {
			display: none;
		}

		.toolbar {
			height: 49px;
			background-image: -webkit-gradient(
				linear,
				left bottom,
				left top,
				color-stop(0.08, rgb(148,145,148)),
				color-stop(0.54, rgb(190,190,190)),
				color-stop(0.77, rgb(222,222,222))
			);
			border-bottom: 1px solid #515151;
		}

		.leftColumn {
			position: absolute;
			left: 0px;
			top: 50px;
			bottom: 0px;
			width: 225px;
			border-right: 1px solid #515151;
		}

		.palette {
			height: 100%;
			display: table;
		}

		.paletteCategory {
			height: 0px;
			display: table-row;
		}

		.paletteCategory.selected {
			height: 100%;
		}

		.paletteCategoryName {
			height: 22px;
			line-height: 22px;
			text-align: center;
			font-family: arial;
			color: #333333;
			font-size: 12px;
			text-shadow: 0px 1px 1px #CDCDCD;
			cursor: pointer;
			background-image: -webkit-gradient(
				linear,
				left bottom,
				left top,
				color-stop(0.08, rgb(148,145,148)),
				color-stop(0.54, rgb(190,190,190)),
				color-stop(0.77, rgb(222,222,222))
			);
		}

		.paletteCategoryItems {
			display: none;
			height: 100%;
			overflow: auto;
			border-bottom: 22px solid transparent;
		}

		.paletteCategory.selected .paletteCategoryName {
			cursor: default;
		}

		.paletteCategory.selected .paletteCategoryItems {
			display: block;
		}

		.paletteItem {
			width: 64px;
			height: 64px;
			float: left;
			cursor: pointer;
			margin-top: 3px;
			margin-left: 3px;
			border-radius: 4px;
			border: 1px solid #DFDFDF;
		}

		.paletteItem:hover {
			background-color: #F3F3F3;
		}

		.paletteItem.selected {
			background-color: #CDCDCD;
			background-image: url('../media/item.gif');
		}

		.paletteItem div {
			width: 64px;
			height: 64px;
			cursor: pointer;
			background-repeat: no-repeat;
			background-position: center center;
			-webkit-background-size: 54px 54px;
		}

		.viewPort {
			position: absolute;
			left: 226px;
			top: 50px;
			right: 0px;
			bottom: 0px;
			overflow: hidden;
		}

		.hide-grid .viewPort {
			background-image: none !important;
		}

		.fpsWindow {
			 position: absolute;
			 top: 10px;
			 color: black;
			 opacity: 0.9;
			 font-family: tahoma;
			 font-size: 23px;
			 right: 15px;
			 z-index: 99999999999;
		}

		-->
		</STYLE>

		<script type="text/javascript">
		
		//REALLY UGLY I KNOW IGNORE PLEASE :P
		
		
		var Class = (function() {

			function wrapConstructorForBase(oConstructor, oSuperClass) {
				if (!oConstructor && !oSuperClass) return oConstructor;
				var oWrapped;
				if (oConstructor) {
					var callsBase = /this\.base/.test(oConstructor);
					if (!callsBase && !oSuperClass) return oConstructor;
					if (!callsBase) oWrapped = function() {
						oSuperClass.apply(this, arguments);
						return oConstructor.apply(this, arguments);
					}; else oWrapped = function() {
						var prev = this.base;
						this.base = (oSuperClass || function(){});
						var result = oConstructor.apply(this, arguments);
						this.base = prev;
						return result;
					};
				} else oWrapped = function() { return oSuperClass.apply(this, arguments); }
				oWrapped.valueOf = function() { return oConstructor; }
				oWrapped.toString = function() { return String(oConstructor); }
				return oWrapped;
			}

			function callFactory(klass, args) {
				var fn = klass.prototype.__factory__.apply(klass, args);
				if ('function' !== typeof(fn)) throw new Error('Factory function doesn\'t return a function');
				fn.__factoryFn__ = true;
				return fn;
			}

			function createFactoryObjects(obj) {
				if (obj.__createFactoryObjects) {
					obj.__createFactoryObjects();
					return;
				}
				//  Create declarative objects
				var p;
				var v;
				for (p in obj.__factories__) {
					v = obj[p];
					if (!v.__factoryFn__) continue;
					obj[p] = v.call(obj);
				}
			}

			function makeConstructor(oConstructor, oSuperClass) {
				if (oConstructor && !(oConstructor instanceof Function)) throw new Error('Invalid constructor');
				if (oSuperClass && !(oSuperClass instanceof Function)) throw new Error('Invalid superclass');
				//  Remove the postConstruct wrapping around the constructor for the superclass.
				oSuperClass = (oSuperClass ? oSuperClass.valueOf() : null);
				//  If the constructor calls this.base, wrap it with the appropriate stuff.
				oConstructor = wrapConstructorForBase(oConstructor, oSuperClass);
				var oWrapped;
				if (oConstructor) oWrapped = function() {
					if (!(this instanceof oWrapped)) return callFactory(oWrapped, arguments);
					var result = oConstructor.apply(this, arguments);
					if (result) return result;
					createFactoryObjects(this);
					if (this.__postConstruct instanceof Function) this.__postConstruct();
					return this;
				}; else oWrapped = function() {
					if (!(this instanceof oWrapped)) return callFactory(oWrapped, arguments);
					createFactoryObjects(this);
					if (this.__postConstruct instanceof Function) this.__postConstruct();
					return this;
				}
				//  make wrapped constructor look like the original
				oWrapped.valueOf = function() { return oConstructor; }
				oWrapped.toString = function() { return String(oConstructor || oWrapped); }
				return oWrapped;
			}

			function makePrototype(oSuperClass) {
				function silent() {}
				silent.prototype = oSuperClass.prototype;
				return new silent();
			}

			function wrapMethodForBase(method, name, superproto) {
				if (!method || !/this\.base/.test(method)) return method;
				function wrappedMethod() {
					var prev = this.base;
					this.base = (superproto[name] || function(){});
					var ret = method.apply(this, arguments);
					this.base = prev;
					return ret;
				}
				wrappedMethod.valueOf = function() { return method; }
				wrappedMethod.toString = function() { return String(method); }
				return wrappedMethod;
			}

			function addMember(proto, name, value, superproto) {
				//  determine whether value is a function that calls this.base()
				if (value instanceof Function && superproto) {
					var realValue = value.valueOf();
					value = wrapMethodForBase(value, name, superproto);
					value.name = name;
					if (realValue.__factoryFn__) proto.__factories__[name] = value;
				}
				proto[name] = value;
				return value;
			}

			function postSubclassNotification(newClass) {
				var klass;
				for (klass = newClass.superclass; klass; klass=klass.superclass) {
					if ('__subclassCreated__' in klass) {
						klass.__subclassCreated__(newClass);
					}
				}
			}

			return {

				create: function(oSuperClass, oDeclaration) {
					if (!arguments.length) throw new TypeError('Missing superclass and declaration arguments');
					var oPrototype = {};
					if (arguments.length == 1) {
						oDeclaration = oSuperClass;
						oSuperClass = undefined;
					} else oPrototype = makePrototype(oSuperClass);
					//  Allow oDeclaration to be a function that returns an object
					if ('function' == typeof(oDeclaration)) {
						oDeclaration = oDeclaration();
						if (!oDeclaration) throw new Error('Class declaration function did not return a prototype');
					}
					var oConstructor = null;
					if (oDeclaration.hasOwnProperty('constructor')) {
						oConstructor = oDeclaration['constructor'];
						delete oDeclaration['constructor'];
					}
					oConstructor = makeConstructor(oConstructor, oSuperClass);
					oConstructor.prototype = oPrototype;
					oConstructor.prototype.constructor = oConstructor;
					oConstructor.superclass = oSuperClass;

					// prepare static members
					for (var sMember in oDeclaration) if (sMember[0] == '_') {
						oConstructor[sMember.substr(1)] = oDeclaration[sMember];
						delete(oDeclaration[sMember]);
					}

					//  Prepare for factory functions in class oDeclaration.
					if (oSuperClass) {
						var fn = (function(){});
						fn.prototype = oSuperClass.prototype.__factories__;
						oPrototype.__factories__ = new fn();
					} else oPrototype.__factories__ = {};
					this.extend(oConstructor, oDeclaration);
					postSubclassNotification(oConstructor);
					return oConstructor;
				},

				extend: (function(){
					if ('__defineGetter__' in Object.prototype) return function(klass, decl) {
						var proto = klass.prototype;
						var superproto = klass.superclass && klass.superclass.prototype;
						var v;
						for (var p in decl) {
							var g = decl.__lookupGetter__(p);
							var s = decl.__lookupSetter__(p);
							if (g || s) {
								g && proto.__defineGetter__(p, g);
								s && proto.__defineSetter__(p, s);
							} else addMember(proto, p, decl[p], superproto);
						}
						return klass;
					}; else return function(klass, decl) {
						var proto = klass.prototype;
						var superproto = klass.superclass && klass.superclass.prototype;
						for (var p in decl) addMember(proto, p, decl[p], superproto);
					};
				})()
			};
		})();
		
		//STRING.JS
		String.prototype.camelize = function() {
			for (var str = '', c = 0; c < this.length; c++) {
				if (this[c] != '-') str += (this[c - 1] == '-' ?
					this[c].toUpperCase() :
					this[c]
				);
			}
			return str;
		};
		
		
		//HTML.JS
		HTMLElement.prototype.setStyle = function(oStyle) {
			for (var sPropertyName in oStyle) {
				this.style[sPropertyName.camelize()] = oStyle[
					sPropertyName
				];
			}
			return this;
		};

		HTMLElement.prototype.queryAncestor = function(sSelector) {
			if (this.webkitMatchesSelector(sSelector)) return this;
			if ((this.parentNode) && (this.parentNode.nodeType == 1)) {
				return this.parentNode.queryAncestor(sSelector);
			}
			return null;
		};

		HTMLElement.prototype.queryMatches = function(sSelector) {
			return this.webkitMatchesSelector(sSelector);
		};

		HTMLElement.prototype.setClass = function(sClassName) {
			this.className = sClassName;
		};

		HTMLElement.prototype.hasClass = function(sClassName) {
			return new RegExp('(\\s|^)' + sClassName + '(\\s|$)').test(this.className);
		};

		HTMLElement.prototype.addClass = function(sClassName) {
			if (this.hasClass(sClassName)) return;
			this.className = (this.className + ' ' + sClassName);
		};

		HTMLElement.prototype.replaceClass = function(sFromClass, sToClass) {
			this.className = this.className.replace(
				new RegExp('(\\s|^)' + sFromClass + '(\\s|$)'),
				sToClass
			);
		};

		HTMLElement.prototype.removeClass = function(sClass) {
			this.replaceClass(sClass, '');
		};
		
		
		//MATH.JS
		
		Math.DEG_TO_RAD = (180 / Math.PI);

		Math.rad2deg = function(iRad) {
			return (iRad * this.DEG_TO_RAD);
		}

		Math.deg2rad = function(iDeg) {
			return (iDeg / this.DEG_TO_RAD);
		}

		Math.point_distance = function(x1, y1, x2, y2) {
			return Math.sqrt(
				Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)
			);
		}

		Math.point_direction = function(x1, y1, x2, y2) {
			return Math.atan2(
				y1 - y2,
				x2 - x1
			);
		}

		Math.circle_point = function(x, y, angle, radius) {
			return [
				x + radius * Math.cos(angle),
				y + radius * Math.sin(angle)
			];
		}
		
		
		//EDITOR.JS
		var TEditor = Class.create({

			map: null,
			objects: {},
			selectedObject: null,

			constructor: function() {
				var oThis = this;
				document.documentElement.addClass('hide-grid');
				document.addEventListener('mousedown', function(oEvent) {
					var oSender = oEvent.target;
					var oToolbarButton = oSender.queryAncestor('.toolbarButton');
					if (oToolbarButton) {
						if (oToolbarButton.hasClass('hideGrid')) {
							document.documentElement.addClass('hide-grid');
						} else if (oToolbarButton.hasClass('showGrid')) {
							document.documentElement.removeClass('hide-grid');
						}
					}
					var oLibraryItem = oSender.queryAncestor('.paletteItem');
					console.log("olibraryitem");
					console.log(oLibraryItem);
					if (oLibraryItem) {
						if (!oLibraryItem.hasClass('selected')) {
							var oSelectedElement = oLibraryItem.parentNode.querySelector('.paletteItem.selected');
							console.log("oSelectedEl");
							console.log(oSelectedElement);
							if (oSelectedElement) oSelectedElement.removeClass('selected');
							oLibraryItem.addClass('selected');


							//alert(":category:"+oLibraryItem.category+":name:"+ oLibraryItem.name);



							oThis.selectedObject = oThis.objects[oLibraryItem.category][oLibraryItem.name];
						} else {
							oLibraryItem.removeClass('selected');
							oThis.selectedObject = null;
						}
						return;
					}
					var oLibraryCategory = oSender.queryAncestor('.paletteCategoryName');
					if (oLibraryCategory) {
						var oCategory = oSender.queryAncestor('.paletteCategory');
						if (oCategory.queryMatches('.selected')) return;
						var oSelectedCategory = oCategory.parentNode.querySelector('.paletteCategory.selected');
						oSelectedCategory.removeClass('selected');
						oCategory.addClass('selected');
					}
				});




			},

			loadLibrary: function(sLibraryUrl, fCallBack) {
				var oThis = this;
				var oXMLHttpRequest = new XMLHttpRequest;
				oXMLHttpRequest.open("GET", sLibraryUrl, true);
				oXMLHttpRequest.onreadystatechange = function() {
					if (this.readyState != 4) return;
					var oDocument = this.responseXML;
					var aBaseURI = oDocument.baseURI.split('/');
					var sBaseURI = (aBaseURI.slice(0, aBaseURI.length - 1).join('/') + '/');
					oThis.parseLibrary(sBaseURI, this.responseXML, fCallBack);
				}
				oXMLHttpRequest.send(null);
			},

			parseLibrary: function(sBaseURI, oLibraryDocument, fCallBack) {
				var oThis = this;
				var iObjectsToLoad = 0;
				for (var oLibraryObjects = oLibraryDocument.evaluate(
					'category/object',
					oLibraryDocument.documentElement,
					null,
					XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,
					null
				), i = 0; i < oLibraryObjects.snapshotLength; i++) {
					var oLibraryObject = oLibraryObjects.snapshotItem(i);
					new function() {
						iObjectsToLoad++;
						var sCategoryName = oLibraryObject.parentNode.getAttribute('name');
						var sObjectId = oLibraryObject.getAttribute('id');
						var sObjectUri = oLibraryObject.getAttribute('uri');
						var oObjectPreloader = document.createElement('img');
						oObjectPreloader.name = sObjectId;
						oObjectPreloader.onload = oObjectPreloader.onerror = function(oEvent) {
							if (!oThis.objects[sCategoryName]) oThis.objects[sCategoryName] = {};
							oThis.objects[sCategoryName][sObjectId] = oObjectPreloader;
							if (!--iObjectsToLoad) fCallBack.call(oThis);
						};
						oObjectPreloader.src = (sBaseURI + sObjectUri);
					}
				}
			},

			renderPalette: function(oElement) {
				var oPalette = oElement.ownerDocument.createElement('div');
				oPalette.className = 'palette';
				for (var sCategoryName in this.objects) {
					if (!oCategoryElement) {
						var oCategoryElement = oElement.ownerDocument.createElement('div');
						oCategoryElement.className = 'selected';
					} else oCategoryElement = oElement.ownerDocument.createElement('div');

					oCategoryElement.addClass('paletteCategory');

					var oCategoryNameElement = oElement.ownerDocument.createElement('div');
					oCategoryNameElement.className = 'paletteCategoryName';

					oCategoryNameElement.innerHTML = (sCategoryName + ' (' + Object.keys(this.objects[sCategoryName]).length + ')');
					oCategoryElement.appendChild(oCategoryNameElement);

					var oCategoryItemsElement = oElement.ownerDocument.createElement('div');
					oCategoryItemsElement.className = 'paletteCategoryItems';
					oCategoryElement.appendChild(oCategoryItemsElement);

					for (var sObjectId in this.objects[sCategoryName]) {
						var oObjectRef = this.objects[sCategoryName][sObjectId];
						var oPaletteItem = oElement.ownerDocument.createElement('div');
						oPaletteItem.className = 'paletteItem';
						oPaletteItem.name = sObjectId;
						oPaletteItem.id = sObjectId;

						oPaletteItem.category = sCategoryName;
						oPaletteItem.appendChild(
							oElement.ownerDocument.createElement('div').setStyle({
								'background-image': 'url("' + oObjectRef.src + '")'
							})
						);
						oCategoryItemsElement.appendChild(oPaletteItem);
					}

					oPalette.appendChild(oCategoryElement);
				}
				oElement.appendChild(oPalette);
			},

			drawGrid: function(iTileWidth, iTileHeight, sColor, oElement) {
				var oCanvas = document.createElement('canvas');
				var oContext = oCanvas.getContext("2d");
				oCanvas.setAttribute('width', iTileWidth);
				oCanvas.setAttribute('height', iTileHeight);
				oContext.strokeStyle = sColor;
				oContext.moveTo(iTileWidth / 2, 0);
				oContext.lineTo(0, iTileHeight / 2);
				oContext.lineTo(iTileWidth / 2, iTileHeight);
				oContext.lineTo(iTileWidth, iTileHeight / 2);
				oContext.lineTo(iTileWidth / 2, 0);
				oContext.stroke();
				oElement.setStyle({'background-image': 'url("'+oCanvas.toDataURL()+'")'});
			},

			renderWorkspace: function(oElement) {
				var iTileWidth = 64;
				var iTileHeight = 32;
				this.map = new TMap(oElement, oElement.offsetWidth, oElement.offsetHeight);
				this.map.initMap(iTileWidth, iTileHeight, 100, 100);
				this.drawGrid(iTileWidth, iTileHeight, '#CDCDCD', oElement);
			},

			loadMapData: function(sMapData) {
				var oThis = this;
				var oDOMParser = new DOMParser();
				var oMapData = oDOMParser.parseFromString(sMapData, "text/xml");
				this.map.processMap(oMapData.documentElement, function() {
					oThis.renderMap(0, 0);
				});
				var oLibraryItem = document.getElementById("surface15");

				if (oLibraryItem) {
					if (!oLibraryItem.hasClass('selected')) {
						var oSelectedElement = oLibraryItem.parentNode.querySelector('.paletteItem.selected');
						if (oSelectedElement) oSelectedElement.removeClass('selected');
						oLibraryItem.addClass('selected');
						oThis.selectedObject = oThis.objects[oLibraryItem.category][oLibraryItem.name];
					} 			
				}
			},

			saveMapData: function() {
				var oXMLDocument = document.implementation.createDocument("", "map", null);
				var oDocumentElement = oXMLDocument.documentElement;
				oDocumentElement.setAttribute('tile-width', this.map.tileWidth);
				oDocumentElement.setAttribute('tile-height', this.map.tileHeight);
				oDocumentElement.setAttribute('map-width', this.map.mapWidthTiles);
				oDocumentElement.setAttribute('map-height', this.map.mapHeightTiles);

				var oTiles = {};
				var oTilesElement = oDocumentElement.appendChild(oXMLDocument.createElement('tiles'));
				var oMapElement = oDocumentElement.appendChild(oXMLDocument.createElement('map'));
				for (var sObjectKey in this.map.objects) {
					var sTileId = this.map.objects[sObjectKey];

					if (!oTiles[sTileId]) {
						oTiles[sTileId] = true;
						var oTileDefElement = oXMLDocument.createElement('tile');
						oTileDefElement.setAttribute('id', sTileId);
						oTileDefElement.setAttribute('uri', this.map.tiles[sTileId].tileUrl);
						oTilesElement.appendChild(oTileDefElement);
					}

					var aObjectPos = sObjectKey.split('.');
					var oTileElement = oXMLDocument.createElement('tile');
					oTileElement.setAttribute('refid', sTileId);
					oTileElement.setAttribute('x', aObjectPos[1]);
					oTileElement.setAttribute('y', aObjectPos[0]);
					oMapElement.appendChild(oTileElement);
				}

				return '<?xml version="1.0" encoding="UTF-8"?>\r\n' + (
					new XMLSerializer()
				).serializeToString(oXMLDocument);
			},

			renderMap: function(iScrollX, iScrollY) {
				this.map.render(iScrollX, iScrollY);

				var iGridX = iScrollX % this.map.tileWidth;
				iGridX = (iGridX >= 0 ? -iGridX : this.map.tileWidth - iGridX);

				var iGridY = iScrollY % this.map.tileHeight;
				iGridY = (iGridY >= 0 ? -iGridY : this.map.tileHeight - iGridY);

				this.map.viewPort.parentNode.setStyle({
					'background-position': iGridX + 'px ' + iGridY + 'px'
				});
			},

		});
		
		
		//END
		
		


					var TEngine = Class.create({
						callback: null,
						eventHandler: null,
						gameState: {
							height: 0,
							keys: {},
							mouse: {},
							metaKey: false
						},
						constructor: function(oViewPort, fCallback) {
							var oThis = this;
							this.viewPort = oViewPort;
							this.callback = fCallback;
							this.eventHandler = function(oEvent) {
								// update metakey state
								oThis.gameState.metaKey = oEvent.metaKey;
								if (oEvent.type == 'keydown') oThis.gameState.keys[oEvent.keyCode] = true;
								else if (oEvent.type == 'keyup') oThis.gameState.keys[oEvent.keyCode] = false;
								else if (oEvent.type == 'mousedown') oThis.gameState.mouse.down = true;
								else if (oEvent.type == 'mouseup') oThis.gameState.mouse.down = false;
								else if (oEvent.type == 'mousemove') {
									oThis.gameState.mouse.x = (oEvent.clientX - oThis.viewPort.offsetLeft);
									oThis.gameState.mouse.y = (oEvent.clientY - oThis.viewPort.offsetTop);
								}
							};
							this.currentIndex1=22;
							this.currentIndex0=10;


						},
						start: function(oViewPort) {
							var oThis = this;
							document.addEventListener('keydown', this.eventHandler, false);
							document.addEventListener('keyup', this.eventHandler, false);
							this.viewPort.addEventListener('mousemove', this.eventHandler, false);
							this.viewPort.addEventListener('mousedown', this.eventHandler, false);
							this.viewPort.addEventListener('mouseup', this.eventHandler, false);
							window.top.testInterval = function() {
								oThis.callback.call(oThis, oThis.gameState);
							}
							for (var c = 0; c < 1; c++) {
								setInterval(window.top.testInterval, 0);
							}

						}
					});

				</script>

				<script type="text/javascript">
					function start() {
						oEditor = new TEditor();
						var gameMatrix = new Array(
							new Array(3,3,3,3,3,3,3,3,3,3,3,3,3),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,2,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,0,0,0,0,0,0,0,0,0,0,0,1),
							new Array(1,1,1,1,1,1,1,1,1,1,1,1,1)

							);
						var realX = 8;
						var realY = 8;

						oEditor.loadLibrary('library/library.xml', function() {

							this.renderPalette(document.querySelector('.leftColumn'));
							this.renderWorkspace(document.querySelector('.viewPort'));
							if (window.XMLHttpRequest)
							  {// code for IE7+, Firefox, Chrome, Opera, Safari
							  xmlhttp=new XMLHttpRequest();
							  }
							else
							  {// code for IE6, IE5
							  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
							  }
							xmlhttp.open("GET","mapDN2.xml",false);
							xmlhttp.send();
							xmlDoc=xmlhttp.responseXML;

							console.log("and this now ");
							console.log(xmlDoc);
							console.log("but finally this");
							console.log(XMLtoString(xmlDoc));
							this.loadMapData(XMLtoString(xmlDoc));



							var iHeight = 0;
							var iScrollX = iNewScrollX = 0;
							var iScrollY = iNewScrollY = 0;
							var iCaptureX = iCaptureY = -1;

							window.addEventListener('resize', function() {
								oEditor.map.initViewPort(oEditor.map.viewPort.offsetWidth, oEditor.map.viewPort.offsetHeight);
								oEditor.renderMap(iScrollX, iScrollY);
							}, false);

							var iSecond = (new Date()).getSeconds();
							var iDate = (new Date());
							var iCounter = 0;
							var oFPSWindow = document.querySelector('.fpsWindow');

							(new TEngine(oEditor.map.viewPort.parentNode, function(oGameState) {

								var iNewSecond = (new Date()).getSeconds();
								iCounter++;

								var aCursorPos = oEditor.map.screen2map(
									oGameState.mouse.x,
									oGameState.mouse.y,
									iScrollX,
									iScrollY
								);


								/*
								var aTilePos = oEditor.map.map2screen(
									aCursorPos[0],
									aCursorPos[1]
								);

								oEditor.cursor.setStyle({
									'left': (aTilePos[0] + 'px'),
									'top': (aTilePos[1] + 'px')
								});
								*/



								if (oGameState.mouse.down) {
									if ((oGameState.metaKey) && (iCaptureX == -1) && (iCaptureY == -1)) {
										iCaptureX = oGameState.mouse.x + iScrollX;
										iCaptureY = oGameState.mouse.y + iScrollY;
									} else if (oGameState.metaKey) {
										iNewScrollX = (iCaptureX - oGameState.mouse.x);
										iNewScrollY = (iCaptureY - oGameState.mouse.y);
										if ((iNewScrollX != iScrollX) || (iNewScrollY != iScrollY)) {
											oEditor.renderMap(iNewScrollX, iNewScrollY);
											iScrollX = iNewScrollX;
											iScrollY = iNewScrollY;
										}
									} else if (oEditor.selectedObject) {






									console.log(oEditor.selectedObject);

									}


								   //


									if((aCursorPos[0] != this.currentIndex0 || aCursorPos[1] != this.currentIndex1) && (aCursorPos[0]!=0 &&aCursorPos[1]!=0)){





									var dif0 = Math.abs(aCursorPos[0]-this.currentIndex0);
									var dif1 = Math.abs(aCursorPos[1]-this.currentIndex1);

									console.log("move from: "+this.currentIndex0+" "+this.currentIndex1);
									console.log("move to: "+aCursorPos[0]+" "+aCursorPos[1]);


									var iNewDate = (new Date());


									if((dif0+dif1)>0 && ((iNewDate - iDate) > 200)){  
										iDate = iNewDate;
										//Move to a different spot
										//Replace old with good grass
										var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
										var sBrush = "mmm2";
										this.activeObject = oEditor.selectedObject;
										oEditor.selectedObject = oEditor.objects["Tiles"]["mmm2"];
										//If it doesn't exist make it
										if (!oEditor.map.tiles[sBrush]) {
											oEditor.map.tiles[sBrush] = oEditor.map.createTile(
												oEditor.selectedObject.src,
												oEditor.selectedObject.width,
												oEditor.selectedObject.height
											);
										}
										//Remove old
										oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
										if (oEditor.map.mapData[sIndex]) {
											oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
											delete(oEditor.map.mapData[sIndex]);
										}
										oEditor.renderMap(iScrollX, iScrollY);

										//THEN
										oEditor.selectedObject = this.activeObject;			

										//Move to a better spot
										var temp1=this.currentIndex1;
										var temp0=this.currentIndex0;
										//Try UP
										temp1--;
										if(temp1%2==0)temp0++;
										if(gameMatrix[realY+1][realX]!=1)var upDif=Math.abs(aCursorPos[0]-temp0)+Math.abs(aCursorPos[1]-temp1);
										else var upDif = 1000;
										temp1=this.currentIndex1;
										temp0=this.currentIndex0;
										//Try DOWN
										temp1++;
										if(temp1%2==1)temp0--;
										if(gameMatrix[realY-1][realX]!=1)var downDif=Math.abs(aCursorPos[0]-temp0)+Math.abs(aCursorPos[1]-temp1);
										else var downDif = 1000;
										temp1=this.currentIndex1;
										temp0=this.currentIndex0;
										//Try LEFT
										temp1--;
										if(temp1%2==1)temp0--;
										if(gameMatrix[realY][realX-1]!=1)var leftDif=Math.abs(aCursorPos[0]-temp0)+Math.abs(aCursorPos[1]-temp1);
										else var leftDif=1000;
										temp1=this.currentIndex1;
										temp0=this.currentIndex0;
										//Try RIGHT
										temp1++;
										if(temp1%2==0)temp0++;
										if(gameMatrix[realY][realX+1]!=1)var rightDif=Math.abs(aCursorPos[0]-temp0)+Math.abs(aCursorPos[1]-temp1);
										else var rightDif =1000;



										if(upDif<downDif&&upDif<leftDif&&upDif<rightDif){
											//Shift active piece UP
											if(gameMatrix[realY+1][realX]==0){
												this.currentIndex1--;
												if(this.currentIndex1%2==0)this.currentIndex0++;
												realY++;
											}else{
												gameEvent(gameMatrix[realY+1][realX]);
												oGameState.mouse.down = false;
											}
										}else if(downDif<leftDif&&downDif<rightDif){		
											//Shift active piece DOWN
											if(gameMatrix[realY-1][realX]==0){
												this.currentIndex1++;
												if(this.currentIndex1%2==1)this.currentIndex0--;
												realY--;
											}else{
												gameEvent(gameMatrix[realY-1][realX]);
												oGameState.mouse.down = false;
											}
										}else if(leftDif<rightDif){
											//Shift active piece LEFT
											if(gameMatrix[realY][realX-1]==0){
												this.currentIndex1--;
												if(this.currentIndex1%2==1)this.currentIndex0--;				
												realX--;					
											}else{
												gameEvent(gameMatrix[realY][realX-1]);
												oGameState.mouse.down = false;
											}	
										}else{
											//Shift active piece RIGHT
											if(gameMatrix[realY][realX+1]==0){
												this.currentIndex1++;
												if(this.currentIndex1%2==0)this.currentIndex0++;
												realX++;
											}else{
												gameEvent(gameMatrix[realY][realX+1]);
												oGameState.mouse.down = false;
											}
										}

										sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
										sBrush = this.currentBrush;
										//If it doesn't exist make it
										if (!oEditor.map.tiles[sBrush]) {
											oEditor.map.tiles[sBrush] = oEditor.map.createTile(
												oEditor.selectedObject.src,
												oEditor.selectedObject.width,
												oEditor.selectedObject.height
											);
										}
										this.currentBrush = sBrush;
										//Remove old
										oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
										if (oEditor.map.mapData[sIndex]) {
											oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
											delete(oEditor.map.mapData[sIndex]);
										}
										oEditor.renderMap(iScrollX, iScrollY);
										//console.info(oEditor.map.tiles);


										dif0 = Math.abs(aCursorPos[0]-this.currentIndex0);
										dif1 = Math.abs(aCursorPos[1]-this.currentIndex1);

									}

								}


								} else if ( oGameState.keys[38] ){ //UP
									//Replace old with good grass
									var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									var sBrush = "mmm2";
									this.activeObject = oEditor.selectedObject;
									oEditor.selectedObject = oEditor.objects["Tiles"]["mmm2"];
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);

									//THEN
									oEditor.selectedObject = this.activeObject;					
									//Shift active piece UP
									this.currentIndex1--;
									if(this.currentIndex1%2==0)this.currentIndex0++;

									sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									sBrush = this.currentBrush;
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									this.currentBrush = sBrush;
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);
									//console.info(oEditor.map.tiles);
									oGameState.keys[38] = false;
								} else if ( oGameState.keys[40] ){ //DOWN
									//Replace old with good grass
									var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									var sBrush = "mmm2";
									this.activeObject = oEditor.selectedObject;
									oEditor.selectedObject = oEditor.objects["Tiles"]["mmm2"];
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);

									//THEN
									oEditor.selectedObject = this.activeObject;
									//Shift active piece DOWN
									this.currentIndex1++;
									if(this.currentIndex1%2==1)this.currentIndex0--;
									var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									var sBrush = this.currentBrush;
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									this.currentBrush = sBrush;
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);
									oGameState.keys[40] = false;
								} else if ( oGameState.keys[37] ){ //LEFT
									//Replace old with good grass
									var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									var sBrush = "mmm2";
									this.activeObject = oEditor.selectedObject;
									oEditor.selectedObject = oEditor.objects["Tiles"]["mmm2"];
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);

									//THEN
									oEditor.selectedObject = this.activeObject;
									//Shift active piece LEFT
									this.currentIndex1--;
									if(this.currentIndex1%2==1)this.currentIndex0--;
									var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									var sBrush = this.currentBrush;
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									this.currentBrush = sBrush;
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);
									//console.info(oEditor.map.tiles);
									oGameState.keys[37] = false;
								} else if ( oGameState.keys[39] ){ //RIGHT
									//Replace old with good grass
									var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									var sBrush = "mmm2";
									this.activeObject = oEditor.selectedObject;
									oEditor.selectedObject = oEditor.objects["Tiles"]["mmm2"];
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);

									//THEN
									oEditor.selectedObject = this.activeObject;
									//Shift active piece RIGHT
									this.currentIndex1++;
									if(this.currentIndex1%2==0)this.currentIndex0++;
									var sIndex = (this.currentIndex1) + '.' + (this.currentIndex0);
									var sBrush = this.currentBrush;
									//If it doesn't exist make it
									if (!oEditor.map.tiles[sBrush]) {
										oEditor.map.tiles[sBrush] = oEditor.map.createTile(
											oEditor.selectedObject.src,
											oEditor.selectedObject.width,
											oEditor.selectedObject.height
										);
									}
									this.currentBrush = sBrush;
									//Remove old
									oEditor.map.objects[sIndex] = (oEditor.selectedObject.name);
									if (oEditor.map.mapData[sIndex]) {
										oEditor.map.mapData[sIndex].parentNode.removeChild(oEditor.map.mapData[sIndex]);
										delete(oEditor.map.mapData[sIndex]);
									}
									oEditor.renderMap(iScrollX, iScrollY);
									//console.info(oEditor.map.tiles);
									oGameState.keys[39] = false;


								} else if ( oGameState.keys[50] ){ //2
									alert(this.currentBrush);

									oGameState.keys[50] = false;

									//mmm2 is good grass



								} else {  
									iCaptureX = -1;
									iCaptureY = -1;
								}

							/*	if (iNewSecond != iSecond) {
									iSecond = iNewSecond;
									oFPSWindow.innerHTML = 'FPS: ' + iCounter;
									iCounter = 0;
								}*/

							})).start();
						});

						//loadScene();
					}

					function saveFileDialogInit() {
						document.querySelector('.saveFileDialog object').addEventListener('onsave', function() {
							return {
								'data': oEditor.saveMapData(),
								'filename': 'map.xml'
							};
						}.toString());
					}

					function XMLtoString(elem){

						var serialized;

						try {
							// XMLSerializer exists in current Mozilla browsers
							serializer = new XMLSerializer();
							serialized = serializer.serializeToString(elem);
						} 
						catch (e) {
							// Internet Explorer has a different approach to serializing XML
							serialized = elem.xml;
						}

						return serialized;
					}



					function openFileDialogInit() {
						document.querySelector('.openFileDialog object').addEventListener('onload', function(sData) {
							console.log("First: ");
							console.log(sData);
							console.log("Second: ");

							if (window.XMLHttpRequest)
							  {// code for IE7+, Firefox, Chrome, Opera, Safari
							  xmlhttp=new XMLHttpRequest();
							  }
							else
							  {// code for IE6, IE5
							  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
							  }
							xmlhttp.open("GET","mapDN2.xml",false);
							xmlhttp.send();
							xmlDoc=xmlhttp.responseXML;

							console.log("and this now ");
							console.log(xmlDoc);
							console.log("but finally this");
							console.log(XMLtoString(xmlDoc));
							oEditor.loadMapData(XMLtoString(xmlDoc));
						}.toString());
					}

					function gameEvent(gameEventNum){
						switch (gameEventNum){
						case 2:
							alert("Hello tree!");
							break;
						case 3:
							alert("Clefairy says 'I don't know how to swim!'");
							break;
						default: break;

						}
					}


				</script>
			</head>
			<body onload="start();">
				<div class="toolbar" style="display:none">



					<div class="toolbarButton toolbarButtonLeft openFileDialog" style="display:none">
						<object>
							<param name="movie" value="scripts/fsutils.swf" />
							<param name="allowScriptAccess" value="sameDomain" />
							<param name="FlashVars" value="onload=openFileDialogInit&dialogType=open&fileFilter=*.xml" />
							<param name="wmode" value="transparent" />
						</object>
						<div>Load Map...</div>
					</div>

					<div class="toolbarButton toolbarButtonLeft saveFileDialog" style="display:none">
						<object>
							<param name="movie" value="scripts/fsutils.swf" />
							<param name="allowScriptAccess" value="sameDomain" />
							<param name="FlashVars" value="onload=saveFileDialogInit&dialogType=save" />
							<param name="wmode" value="transparent" />
						</object>
						<div>Save Map...</div>
					</div>

					<div class="toolbarButton toolbarButtonRight hideGrid" style="display:none">Hide Grid</div>
					<div class="toolbarButton toolbarButtonRight showGrid" style="display:none">Show Grid</div>

				</div>
				<div class="leftColumn" style="display:none"></div>
				<div class="viewPort">
					<div class="fpsWindow"></div>
				</div>
			</body>
		</html>

		
		
		
		
		
		
		
		